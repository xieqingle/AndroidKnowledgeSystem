# I/O多路复用

I/O 模型的演进史，其实就是操作系统的优化历史，随着高并发场景越来越多，用户态越来越繁忙，倒逼着操作系统将更多的功能加到自己的内核。

这种 单线程 + 多路复用 + 事件通知 来处理 I/O 的模式的兴起，归根结底本质就是：减少指令运行数量，达到优化目的。减少了什么指令？减少了系统调用，从原来的多次系统调用，变成了一次系统调用 + 内核层自己干活，自己遍历这些 fd。

## 博文

- [读取文件时，程序经历了什么？](https://zhuanlan.zhihu.com/p/260375849)
> 要想知道 I/O 多路复用解决了什么问题，就得先扒一扒 I/O 的基础概念，知道 I/O 的分类：同步阻塞 I/O、同步非阻塞式 I/O、异步阻塞 I/O（即多路复用）。

- [你管这破玩意叫 I/O 多路复用 ？—— 码农的荒岛求生](https://zhuanlan.zhihu.com/p/265183019)
> 通俗生动地解释了 epoll 诞生的背景，适合入门

- [你管这破玩意叫 IO 多路复用？—— 低并发编程](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247494866&idx=1&sn=0ebeb60dbc1fd7f9473943df7ce5fd95&chksm=c2c5967ff5b21f69030636334f6a5a7dc52c0f4de9b668f7bac15b2c1a2660ae533dd9878c7c&mpshare=1&scene=1&srcid=04239yXVUr6ekmLg7ZSKlFpa&sharer_sharetime=1619147468052&sharer_shareid=2498540345d210ebc4198a40ae94e9ec#rd)
> 在我复习 epoll 时，发现知识点难以具象，导致难以记忆，这不，这篇文章适时地出现了，gif 图甚得我心。附说一句，低并发编程公众号出品，基本每一篇都是精品。

- [Epoll原理解析](https://blog.csdn.net/armlinuxww/article/details/92803381)
> 在入完门后，你需要这么一篇娓娓道来的解析，epoll 使用了红黑树来存储所有的 fd，而这个数据结构的查找和插入性能非常优异稳定，都是 O(logn)，看到公式，你可能还不明白这个降维打击的厉害之处，举个例子，如果 fd 有十万个，查找一个特定的元素不会高于 12 次查询，你看比原来的 select 的遍历查询 O(n) 少了多少个数量级；就算 fd 有 4 亿个，查询也只要30多次即可！是不是很神奇。
所以，有了红黑树有了 epoll，这才使得单线程管理海量的 socket 成为了现实。

## 扩展

为什么 Handler 中会利用到 epoll？

一种说法是：当通过 postDelayed 发送延时消息后，会调用 epoll_wait 的 timeout 进行等待，利用了 epoll_wait 函数的挂起，达到了延时的目的，时间到后阻塞结束，epoll_wait 返回，线程被重新唤醒并获得CPU资源。
第二种说法是：为了省电，虽然 Looper 无限循环，但是没活干了就释放 CPU 资源进入休眠状态，并不会消耗大量资源。
还有一种说法是：为了可以同时处理 native 侧消息

存疑，挖个坑待我回来填。
